# 启动脚本说明

## 脚本功能

### start_all.sh - 启动所有服务

**功能：**
- 自动检查 MySQL 是否运行
- 创建 Python 虚拟环境（如果不存在）
- 安装 Python 依赖（如果未安装）
- 启动后端服务（uvicorn，端口 43211）
- 安装前端依赖（如果未安装）
- 启动前端服务（vite，端口 11234）

**使用方法：**
```bash
sh start_all.sh
```

**停止服务：**
- **按 Ctrl+C 会同时停止前后端所有进程**
- 脚本会捕获 SIGINT、SIGTERM 和 EXIT 信号
- 优雅关闭：先发送 TERM 信号，1秒后若未退出则强制 KILL
- 自动清理所有子进程

### start_backend.sh - 仅启动后端

**功能：**
- 启动后端服务（前台运行）

**使用方法：**
```bash
sh start_backend.sh
```

**停止服务：**
- 按 Ctrl+C 停止

### start_frontend.sh - 仅启动前端

**功能：**
- 启动前端服务（前台运行）

**使用方法：**
```bash
sh start_frontend.sh
```

**停止服务：**
- 按 Ctrl+C 停止

### stop_all.sh - 停止所有服务

**功能：**
- 停止所有运行中的前后端进程

**使用方法：**
```bash
sh stop_all.sh
```

## 重要修复（2025-12-17）

### 问题
之前 `start_all.sh` 使用 Ctrl+C 退出时，后端进程没有被正确关闭，导致进程残留。

### 修复内容
1. **进程管理优化**
   - 使用正确的 uvicorn 命令：`uvicorn app:app --host 0.0.0.0 --port 43211`
   - trap 捕获 EXIT 信号，确保脚本退出时清理所有子进程
   
2. **清理逻辑增强**
   - 优先使用 `kill -TERM` 优雅关闭
   - 1秒后检查进程是否存在，若存在则 `kill -9` 强制关闭
   - 使用精确的进程匹配规则避免误杀
   
3. **同步更新**
   - `start_backend.sh` 也改用 uvicorn 启动
   - `stop_all.sh` 使用与 start_all.sh 一致的进程匹配规则

### 测试验证
启动服务后，按 Ctrl+C：
```bash
# 验证前端进程已停止
ps aux | grep "vite --port 11234" | grep -v grep

# 验证后端进程已停止  
ps aux | grep "uvicorn app:app --host 0.0.0.0 --port 43211" | grep -v grep
```

两个命令都应该没有输出，表示进程已完全清理。

## 故障排查

### 如果 Ctrl+C 后进程仍未关闭

手动执行清理：
```bash
sh stop_all.sh
```

或者手动查找并杀死进程：
```bash
# 查找后端进程
ps aux | grep "uvicorn app:app"

# 查找前端进程
ps aux | grep "vite --port 11234"

# 使用 PID 杀死进程
kill -9 <PID>
```

### 如果端口被占用

```bash
# 查找占用 43211 端口的进程
lsof -ti:43211 | xargs kill -9

# 查找占用 11234 端口的进程
lsof -ti:11234 | xargs kill -9
```

